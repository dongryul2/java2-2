# 한동렬 202030334

## 5월 3일 수업내용

### 컬렉션의 특징
1.컬렉션은 제네릭 기법으로 구현

- 제네릭
> 특정 타입만 다루지 않고, 여러 종류의 타임으로 변신할 수 있도록 클래스나 메소드를 일반화 시키는 기법
> 클래스나 인터페이스 이름에 <E> <K> <V> 등 타입매개변수 포함
제네릭 컬렉션 사례: 벡터 Vector<E>
> <E>에서 E에 구체적인 타입을 주어 구체적인 타입만 다루는 벡터로 활용
> 정수맍 다루는 컬렉션 벡터 Vector<Integer>
>문자열만 다루는 컬렉션 벡터 Vector<String>

2.컬렉션의 요소는 객체만 가능

* int,char,double 등의 기본 타입으로 구체화 불가

### Vector<E>
벡터 Vector<E>의 특징
- <E>에 사용할 요소의 특정 타입으로 구체화
- 배열을 가변 크기로 다룰 수 있게 하는 컨테이너
- 요소 객체들을 삽입,삭제,검색하는 컨테이너
- Vector에 삽입 가능한 것
> 객체,null
> 기본 타입의 값은 Wrapper 객체로 만들어 저장
- Vector에 객체 삽입
> 벡터의 맨 뒤, 중간에 객체 삽입가능
- Vector에서 객체 삭제
> 임의의 위치에 있는 객체 삭제 가능

### 컬렉션 생성문의 진화 : JAVA7 JAVA10

### ArrayList <E>
가변 크기 배열을 구현한 클래스
- <E>에 요소로 사용할 특정 타입으로 구체화
벡터와 거의 동일
- 요소 삽입,삭제,검색 등 벡터 기능과 거의 동일
- 벡터와 달리 스레드 동기화 기능 없음

### 컬렉션의 순차 검색을 위한 iterator
iterator<E> 인터페이스
- 리스트 구조의 컬렉션에서 요소의 순차 검색을 위한 인터페이스

iterator 객체 얻어내기
- 컬렉션의 iterator()메소드 호출
- 컬렉션 검색 코드

### HashMap<K,V>
키와 값의 쌍으로 구성되는 요소를 다루는 컬렉션
- K: 키로 사용할 요소의 타입
- V: 값으로 사용할 요소의 타입
- 키와 값이 한 쌍으로 삽입
- '값'을 검색하기 위해서는 반드시 '키' 이용

삽입 및 검색이 빠른 특징
- 요소 삽입 : put() 메소드
- 요소 검색 : get() 메소드

### 자바의 GUI
GUI 응용프로그램
-GUI
    > 사용자가 편리하게 입출력 할 수 있도록 그래픽으로 화면을 구성하고,마우스나 키보드로 입력 받을 수 있도록 지원하는 사용자 인터페이스
- 자바 언어에서 GUI 응용프로그램 작성
    > AWT와 Swing 패키지에 강력한 GUI 컴포넌트 제공
    > 쉬운 GUI 프로그래밍
AWT와 Swing 패키지
- AWT 패키지
    > 자바가 처음 나왔을 때부터 배포된 GUI 패키지, 최근에는 거의 사용하지 않음
    > AWT 컴포넌트는 중량 컴포넌트
- Swing 패키지
    > AWT 기숳을 기반으로 작성된 자바 라이브러리
    > 모든 AWT 기능 + 추가된 풍부하고 화려한 고급 컴포넌트
    > AWT 컴포넌트를 모두 스윙으로 재작성

### 스윙 프레임
스윙 프레임: 모든 스윙 컴포넌트를 담는 최상위 컨테이너
- JFrame을 상속받아 구현
- 컴포넌트들은 화면에 보이려면 스윙 프레임에 부착되어야 함
    > 프레임을 담으면 프레임에 부착된 모든 컴포넌트가 보이지 않게 됨

### 프레임 만들기,JFrame 클래스 상속
스윙 프레임
- JFrame 클래스를 상속받은 클래스 작성
- 프레임의 크기 반드시 지정: setSize() 호출
- 프레임을 화면에 출력하는 코드 반드시 필요 : setVisivle(true) 호출

### 스윙 응용프로그램에서 main()의 기능과 위치
스윙 응용프로그램에서 main()의 기능 최소화 바람직
- 스윙 응용프로그램이 실행되는 시작점으로서 기능만
- 스윙 프레임을 생성하는 정도의 코드로 최소화

### 프레임에 컴포넌트 붙이기

1.타이틀 달기
-super()나 setTitle()이용

2.컨텐트팬에 컴포넌트 달기
- 컨텐트팬: 스윙 컴포넌트들이 부착되는 공간

3.컨텐트팬 알아내기
- 스윙 프레임에 붙은 디폴트 컨텐트팬 알아내기

4.컨텐트팬에 컴포넌트 붙이기

5.컨텐트팬 변경



## 4월 12일

### 접근 지정자 
1.private  
2.protected  
3.public  
4.디폴트(접근지정자 생락)

접근지정자의 목적
- 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 혀용
- 객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것

### 클래스 접근 지정
다른 클래스에서 사용하도록 허용할 지 지정

public 클래스
- 다른 모든 클래스에게 접근 허용

디폴트 클래스(접근지정자 생략)
- package-private라고도 함
- 같은 패키지의 클래스에만 접근 허용

### 멤버 접근 지정
public 멤버
- 패키지에 관계 없이 모든 클래스에게 접근 허용

private 멤버
- 동일 클래스 내에만 접근 허용
- 상속 받은 서브 클래스에서 접근 불가

protected 멤버
- 같은 패키지 내의 다른 모든 클래스에게 접근 허용

### static 멤버
static 멤버 선언


- class StaticSample {  
  int n;      // non-static 필드  
  void g() {...}       //non-static 메소드  

  static int m;        //static-필드  
  static void f() {...}       //static-메소드  
}

static 멤버의 생성
- static 멤버는 클래스당 하나만 생성
- 객체들에 의해 공유됨

### static 메소드의 제약 조건 1

static 메소드는 오직 static 멤버만 접근 가능

- 객체가 생성되지 않은 상황에서도 static 메소드는 실행될 수 있기 때문에 non-static 멤버 활용 불가
- non-static 메소드는 static 멤버 사용 가능

### static 메소드의 제약 조건 2
static 메소드느 this 사용불가
- static 메소드는 객체 없이도 사용 가능하므로, this 레퍼런스 사용할 수 없음

### final 클래스와 메소드
final 클래스 - 더 이상 클래스 상속 불가능  
final 메소드 - 더 이상 오버라이딩 불가능

### final 필드
final 필드, 상수 선언
- 상수를 선언할 때 사용
- 상수 필드는 선언 시에 초기 값을 지정하여야 한다
- 상수 필드는 실행 중에 값을 변경할 수 없다

### 클래스 상속과 객체
상속 선언
- extends 키워드로 선언
- 부모 클래스 > 슈퍼 클래스(super class)
- 자식 클래스 > 서브 클래스(sub class)

### 자바 상속의 특징
클래스 다중 상속 불허
- C++는 다중 상속 가능
- 자바는 인터페이스의 다중 상속 허용

모든 자바 클래스는 묵시적으로 Object클래스 상속받음
- java.lang.Object는 클래스는 모든 클래스의 슈퍼 클래스

### 슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
슈퍼 클래스의 private 멤버
- 서브 클래스에서 접근할 수 없음  

슈퍼 클래스의 디폴트 멤버
- 서브 클래스가 동일한 패키지에 있을때 접근 가능

### protected 멤버
protected 멤버에 대한 접근
- 같은 패키지의 모든 클래스에게 허용
- 상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용

### 서브 클래스/슈퍼 클래스의 생성자 호출과 실행
서브 클래스의 객체가 생성될 때
- 슈퍼클래스 생성자와 서브 클래스 생성자 모두 실행
- 호출 순서 ----------------  
  서브 클래스의 생성자 먼저 호출  
  서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출  

- 실행 순서 ------------------  
  슈퍼 클래스의 생성자가 먼저 싱행된 후 서브 클래스의 생성자 실행

### 서브 클래스와 슈퍼 클래스의 생성자 선택
슈퍼 클래스와 서브 클래스
- 각각 여러 개의 생성자 작성 가능

서브 클래스의 객체가 생성될 때
- 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행

서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식
1. 개발자의 명시적 선택
- 서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택
- super() 키워드를 이용하여 선택
2. 컴파일러가 기본생성자 선택
- 서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않는 경우
- 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택

###  super()로 슈퍼 클래스의 생성자 명시적 선택
super()
- 서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 호출

### 다운캐스팅
다운캐스팅(downcasting)
- 슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
- 업캐스팅된 것을 다시 원래대로 되돌리는 것
- 반드시 명시적 타입 변환 지정














## 4월 05일

### 2차원 배열의 length 필드

i.length :2차원 배열의 행의 개수로,2  
i[n].length : n번째 행의 열의개수  
i[1].length: 1번째 행의 열의 개수, 5

### 배열 리턴
- 배열의 레퍼런스만 리턴(베열 전체가 리턴되는 것이 아님)

### 메소드의 리턴 타입
-  리턴하는 배열 타입과 리턴 받는 배열 타입 일치  
-  리턴 타입에 배열의 크기를 지정하지 않음

### 자바의 예외 처리
   예외(exception)   
-  실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생   

예외 처리
- 발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것

### 실세계 객체의 특징
  객체마다 고유한 특성(state)와 행동(behavior)를 가짐

캡슐화 : 객체를 캡슐로 써서 내부를 볼 수 없게 하는 것

자바의 캡슐화

- 클래스 : 객체 모양을 선언한 틀(캡슐호하하는 틀)  
- 객체 : 생성된 실체(instance)

자바 상속
- 상위 클래스 : 수퍼 클래스
- 하위 클래스 : 서브 클래스,수퍼 클래스 코드의 재사용, 새로운 특성 추가 기능

### 객체 지향 언어의 목적
1. 소프트웨어의 생산성 향상
-  컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축
- 객체 지향 언어

2. 실세계에 대한 쉬운 모델릴
- 초기 프로그래밍
- 현대 프로그래밍
- 객체 지향 언어

### 클래스와 객체
클래스
- 객체의 속성과 행위 선언
- 객체의 설계도 혹은 틀

객체
- 클래스의 틀로 찍어낸 실체

### 기본 생성자
기본생성자
- 매개 변수 없고,아무 작업 없이 단순 리턴하는 생성자
- 디폴트 생성자 라고도 불림

### this 레퍼런스
this
- 객체 자신에 대한 레퍼런스 ---------------------  
컴파일러에 의해 자동관리,개발자는 사용하기만 하면 됨.  
this.멤버 형탸로 멤버를 접근할 때 사용.

### 메소드
메소드
- 메소드는 c/c++의 함수와 동일  
  자바의 모든 메소드는 반드시 클래스 안에 있어야함

접근지정자
-  다른클래스에서 메소드를 접근할 수 있는지 여부 선언

### 메소드 오버로딩
오버로딩
- 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성

### 객체 소멸
new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위

### 가비지
가비지
- 가리키는 레퍼런스가 하나도 없는 객체--------   
더이상 접근할 수 없어 사용할 수 없게 된 메모리

가비지 컬렉션
- 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환
- 자바 가상 기계가 기비지 자동회수--------------------  
1.가용 메모리 공간이 일정 이하로 부족해질때  
2.가비지를 수거하여 가용 메모리 공간으로 확보  
- 가비지 컬렉터(garbage collector)에 의해 자동 수행

강제 가비지 컬렉션 강제 수행
- System 또는 Runtime 객체의 gc() 메소드 호출

### 자바의 패키지 개념
패키지
- 상호 관련 있는 클래스 파일(컴파일된 .class)을 저장하여 관리하는 디렉터리
- 자바 응용프로그램은 하나 이상의 패키지로 구성



## 3월 29일 수업내용

# 정수 리터럴
15 -> 10진수
015 -> 0으로 시작하면 8진수, 10진수로 13
0x15 -> 0x로 시작하면 16진수, 10진수로 21
0b0101 -> 0b로 시작하면 2진수, 10진수로 5

## Long 타입으로 지정할땐 
long i = 24l; 이런식으로 l이나 L을 붙이면 된다

## 실수 리터럴
실수 리터럴은 소수점 형태나 지수형태로 실수를 표현한 값
예: 12. 12.0 .1234 0.1234 1234E-4

## 실수 리터럴은 double타입으로 자동 처리되며 변수와 함꼐 사용하면 된다
double d = 0.1234;
double e = 1234E-4; <- 1234E-4 = 1234x10<sup>-4</sup>이므로 0.1234와 동일

## 숫자 뒤에 f또는 F를 붙이면 float으로 d 또는 D를 붙이면 double타입으로 강제 변환 할수있다
float f = 0.1234f; <- 0.1234는 원래 double타입이므로 
double w = .1234D; <- .1234D와 .1234는 동일

# 문자 리터럴
문자 리터럴은 단일 인용부호('')로 문자를 표현하거나 \u 다음에 문자의 유니코드값을 사용하여 표한한다 
예: 'a', 'W', '가’, '3', '글'

변수와 함께쓰면
char a = 'W';
char b = '글';
char c = \uae00; <- 글의 유니코드 값 ae00을 \u뒤에 사용

# 특수문자 리터럴
백슬래쉬(\) 다음에 특수 기호를 붙여서 표한하는데 이를 이스케이프 시퀸스(escape sequence)라고 한다

종류
'\b' <- 백스페이스
'\t' <- 탭
'\n' <- 라인피드(줄바꿈)
'\f' <- 폼피드(커서를 다음 페이지의 시작부분으로 넘김)
'\r' <- 캐리지 리턴(커서를 다음줄로 넘기지 않고 첫 번째 위치로 넘김)
'\"' <- 큰따옴표
'\'' <- 작은따옴표
'\\' <- 백슬래쉬(역슬래쉬)

# null 리터럴
null은 기본 타입에 사용하지못하고 객체 레퍼런스에 대입된다

## null은 int,double,boolean등과 같은 기본타입에 적용불가

String str = null; <- 이런식으로 사용

# 문자열(String) 리터럴
"hello"와 같이 큰따옴표에 묶어서 표현한다
String str = "hello";

# var 키워드
java10부터 var키로드를 사용하여 타입을 생략하고 간단히 변수선언 가능
var키워드는 자동으로 타입 결정
## 초깃값이 주어지지 않으면 오류 발생
## 지역 변수로만 사용가능

# 상수 
리터럴을 상수로 선언하면 변수처럼 표현 가능
상수는 final키워드를 사용하여 선언

final double PI = 3.141592;
final -> 상수선언
double -> 데이터 타입
PI -> 상수 이름
3.141592 -> 이 값으로 초기화

## final키워드를 사용할땐 앞에 static을 붙여줘야 좋다

# 타입변환

## 자동 타입 변환
다음과 같이 치환문(=)이나 타입이 일치하지 않을 때 컴파일러는 작은 타입을 큰 타입으로 자동변환
long m = 24; <- 25는 int타입으로서 long타입으로 자동변환
double d = 3.14 * 10; <- 실수를 연산하기위해 10.0으로 자동변환

## 강제 타입 변환
int n = 300;
작은 타입에서 큰타입으로 변환 가능
큰 타입에서 작은타입으로 변환하면 컴파일러는 오류를 발생시킨다

손실이 발생한다는걸 알고도 강제 변환하려면 
byte b = (byte)n;
이처럼 괄호안에 타입을 넣어서 강제 변환이 가능하다

## 강제 타입 변환을 캐스팅(casting)이라고도 부른다.

## if문 종류

# 다중 if-else문 

if(조건식1) {
    실행문장 1;
}
else if(조건식 2) {
    실행문장 2;
}
else if(조건식 3) {

}

## FourSeasons.java 참고

# 중첩 if-else문

if안에 if를 넣는 방식 

# Switch문

switch(식) {
 case 값1:
    실행 문장 1;
    break;
 case 값2:
    실행 문장2;
    break;
    ...
 case 값m:
    실행 문장 m;
    break;
 default:
    실행 문장 n;
}

# switch문에서 break문의 역할

switch문 내의 break문
    break문을 만나면 switch문 벗어남
    case문에 break문이 없다면, 다음 case문으로 실행 계속
     break를 만날 때까지 계속 내려 가면서 실행 

# case 문의 값
    문자, 정수, 문자열 리터럴(JDK 1.7부터)만 허용
    실수 리터럴은 허용되지 않음

#
    int b;
    switch(b%2) {
        case 1: ...; break;
        case 2: ...; break;
    }

    char c;
    switch(c) {
        case '+': ...; break;
        case '+': ...; break;
    }

    String s ="예";
    switch(s){
        case "예" ...; break;
        case "아니오" ...; break; 
    }

# 반복문 

자바 반복문 - for 문, while 문, do-while 문

for 문 - 가장 많이 사용하는 반복문 


## while 문의 구성과 코드 사례

while(조건식) {
    작업문
}

조건식이 '참'인 동안 반복 실행

예시
it i=0;
while(i<10) {
    System.out.print(i);
    i++;
}

# 자바 배열

배열(array)
    인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조 
        배열을 이용하면 한 번에 많은 메모리 공간 선언 가능

    # 배열은 같은 타입의 데이터들이 순차적으로 저장되는 공간

        원소 데이터들이 순차적으로 저장됨
        인덱스를 이용하여 원소 데엍 접근
        반복문을 이용하여 처리하기에 적합한 자료 구조

    # 배열 인덱스
        0부터 시작
        인덱스는 배열의 시작 위치에서부터 데이터가 있는 상대 위치 

## 배열 선언과 생성
    (1) 배열에 대한 레퍼런스 변수 intArray 선언

        int intArray [];

    (2) 배열 생성

        intArray = new int [5];

## 배열 선언 및 생성 디테일

배열 선언
    int intArray [];

    int[] intArray;

배열 생성 
    intArray = new int[5];

    int intArray[] = new int[5];

배열 초기화
    int intArray[] = {4, 3, 2, 1, 0};

## 배열 인덱스
    배열의 인덱스는 0 ~ *배열 크기-1
        int intArray = new int[5];
        intArray[0] = 5;
        intArray[3] = 6;
        int n = intArray[3];

    인덱스를 잘못 사용한 경우
        int n = intArray[-2];
        int m = inArray[5];

    반드시 배열 생성 후 접근
        int intArray []; //레퍼런스만 선언함

        intArray[1] =8; //오류. 배열이 생성되어 있지 않음
    

## 3월 22일

## 3월 15일 
내용

